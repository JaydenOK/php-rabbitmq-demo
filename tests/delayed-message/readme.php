<?php
/**
 *
 * 存在的一些问题
 * 消耗系统内存，如果定时任务很多，长时间得不到释放，将会一直占用系统进程耗费内存。
 * 单线程如何保障出现系统崩溃后之前的定时任务不受影响？多进程集群模式下一致性的保证？
 * setTimeout、setInterval 会存在时间误差，对于时间精度要求较高的是不行的。
 * RabbitMQ TTL+DLX 实现定时任务
 * RabbitMQ 本身是不支持的，可以通过它提供的两个特性 Time-To-Live and Expiration、Dead Letter Exchanges 来实现
 *
 *
 * ############################################  dead-letter-exchange   ######################################
 *
 *死信队列介绍
死信队列：DLX，dead-letter-exchange
利用DLX，当消息在一个队列中变成死信 (dead message) 之后，它能被重新publish到另一个Exchange，这个Exchange就是DLX

 * 死信队列
 * 死信队列全称 Dead-Letter-Exchange 简称 DLX 是 RabbitMQ 中交换器的一种类型，消息在一段时间之后没有被消费就会变成死信被重新 publish 到另一个 DLX 交换器队列中
 * ，因此称为死信队列。
 * 死信队列产生几种情况
 * 消息被拒绝
 * 消息 TTL 过期
 * 队列达到最大长度
 *
 * 设置DLX的两个参数：
 * deadLetterExchange: 设置 DLX，当正常队列的消息成为死信后会被路由到 DLX 中
 * deadLetterRoutingKey: 设置 DLX 指定的路由键
 * 注意：Dead-Letter-Exchange 也是一种普通的 Exchange
 * 消息 TTL
 * 消息的 TTL 指的是消息的存活时间，RabbitMQ 支持消息、队列两种方式设置 TTL，分别如下：
 * 消息设置 TTL：对消息的设置是在发送时进行 TTL 设置，通过 x-message-ttl 或 expiration 字段设置，单位为毫秒，代表消息的过期时间，每条消息的 TTL 可不同。
 * 队列设置 TTL：对队列的设置是在消息入队列时计算，通过 x-expires 设置，队列中的所有消息都有相同的过期时间，当超过了队列的超时设置，消息会自动的清除。
 * 注意：如果以上两种方式都做了设置，消息的 TTL 则以两者之中最小的那个为准。
 *
 *注意问题
 *
 * 一个队列里的某个消息即使比同队列中的其它消息提前过期，也不会优先进入到死信队列，只有当过期的消息到了队列的顶端，才会被真正的丢弃或者进入死信队列。
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 * ############################################  x-delayed-message   ######################################
 * 实现原理
 * 上面使用 DLX + TTL 的模式，消息首先会路由到一个正常的队列，根据设置的 TTL 进入死信队列，与之不同的是通过 x-delayed-message 声明的交换机，它的消息在发
 * 布之后不会立即进入队列，先将消息保存至 Mnesia（一个分布式数据库管理系统，适合于电信和其它需要持续运行和具备软实时特性的 Erlang 应用。目前资料介绍的不是很多）
 * 这个插件将会尝试确认消息是否过期，首先要确保消息的延迟范围是 Delay > 0, Delay =< ?ERL_MAX_T（在 Erlang 中可以被设置的范围为 (2^32)-1 毫秒），如果消息过期通
 * 过 x-delayed-type 类型标记的交换机投递至目标队列，整个消息的投递过程也就完成了。
 *
 *
 * 构建生产者
 * 几个注意点：
 * 交换机类型一定要设置为 x-delayed-message
 * 设置 x-delayed-type 为 direct，当然也可以是 topic 等
 * 发送消息时设置消息头 headers 的 x-delay 属性，即延迟时间，如果不设置消息将会立即投递
 *
 *
 *
 * 局限性
 * Delayed Message 插件实现 RabbitMQ 延迟队列这种方式也不完全是一个银弹，它将延迟消息存在于 Mnesia 表中，并且在当前节点上具有单个磁盘副本，它们将在节点重启之后幸存。
 * 目前该插件的当前设计并不真正适合包含大量延迟消息（例如数十万或数百万）的场景，详情参见 #/issues/72 另外该插件的一个可变性来源是依赖于 Erlang 计时器，在系统
 * 中使用了一定数量的长时间计时器之后，它们开始争用调度程序资源，并且时间漂移不断累积。
 * 插件的禁用要慎重，以下方式可以实现将插件禁用，但是注意如果此时还有延迟消息未消费，那么禁掉此插件后所有的未消费的延迟消息将丢失。
 * rabbitmq-plugins disable rabbitmq_delayed_message_exchange
 * 如果你采用了 Delayed Message 插件这种方式来实现，对于消息可用性要求较高的，在发现消息之前可以先落入 DB 打标记，消费之后将消息标记为已消费，中间可以加入定
 * 时任务做检测，这可以进一步保证你的消息的可靠性。
 *
 * 总结
 * 经过一番实践测试、学习之后发现，DLX + TTL 和 Delayed Message 插件这两种 RabbitMQ 延迟消息解决方案都有一定的局限性。
 * 如果你的消息 TTL 是相同的，使用 DLX + TTL 的这种方式是没问题的，对于我来说目前还是优选。
 * 如果你的消息 TTL 过期值是可变的，可以尝试下使用 Delayed Message 插件，对于某些应用而言它可能很好用，对于那些可能会达到高容量延迟消息应用而言，则不是很好。
 * 关于 RabbitMQ 延迟队列，如果你有更多其它实现，欢迎关注公众号 “Nodejs技术栈” 在后台取得我的联系方式进行讨论，我很期待。
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */